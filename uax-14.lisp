#|
 This file is a part of UAX-14
 (c) 2019 Shirakumo http://tymoon.eu (shinmera@tymoon.eu)
 Author: Nicolas Hafner <shinmera@tymoon.eu>
|#

(in-package #:org.shirakumo.alloy.uax-14)

(declaim (ftype (function ((unsigned-byte 8)) (unsigned-byte 8)) normalize-break-id))
(defun normalize-break-id (id)
  (declare (type (unsigned-byte 8) id))
  (declare (optimize speed))
  (cond ((or (= id (type-id :AI))
             (= id (type-id :SA))
             (= id (type-id :SG))
             (= id (type-id :XX)))
         (type-id :AL))
        ((= id (type-id :CJ))
         (type-id :NS))
        (T
         id)))

(declaim (ftype (function ((unsigned-byte 8)) (unsigned-byte 8)) normalize-first-break))
(defun normalize-first-break (id)
  (declare (type (unsigned-byte 8) id))
  (declare (optimize speed))
  (cond ((or (= id (type-id :LF))
             (= id (type-id :NL)))
         (type-id :BK))
        ((= id (type-id :SP))
         (type-id :WJ))
        (T
         id)))

(declaim (inline code-point-at))
(declaim (ftype (function (string idx) (values code idx)) code-point-at))
(defun code-point-at (string start)
  (declare (type (vector character) string))
  (declare (type idx start))
  (declare (optimize speed))
  (let ((code (char-code (char string start)))
        (next (if (< start (- (length string) 2))
                  (char-code (char string (1+ start)))
                  #x10FFFF)))
    (if (and (< #xD800 code)
             (<= code #xDBFF)
             (<= #xDC00 next)
             (<= next #xDFFF))
        (values (+ (* (- code #xD800) #x400)
                   (- next #xDC00)
                   #x10000)
                (+ start 2))
        (values code
                (+ start 1)))))

(declaim (ftype (function ((unsigned-byte 8) (unsigned-byte 8)) (or null (unsigned-byte 8))) handle-simple-break))
(defun handle-simple-break (next-class cur-class)
  (declare (type (unsigned-byte 8) next-class cur-class))
  (declare (optimize speed))
  (cond ((= next-class (type-id :SP))
         cur-class)
        ((or (= next-class (type-id :BK))
             (= next-class (type-id :LF))
             (= next-class (type-id :NL)))
         (type-id :BK))
        ((= next-class (type-id :CR))
         (type-id :CR))
        (T
         NIL)))

(defstruct (breaker (:constructor %make-breaker (string)))
  (string NIL :type string)
  (pos 0 :type idx)
  (last-pos 0 :type idx)
  (cur-class 0 :type (unsigned-byte 8))
  (next-class 0 :type (unsigned-byte 8))
  (lb8a NIL :type boolean)
  (lb21a NIL :type boolean)
  (lb30a 0 :type idx))

(defun make-breaker (string &optional breaker)
  (if breaker
      (setf (breaker-string breaker) string)
      (setf breaker (%make-breaker string)))
  (multiple-value-bind (code new-pos) (if (string/= "" string)
                                          (code-point-at string 0)
                                          (values 0 0))
    (let ((first-class (normalize-break-id (line-break-id code))))
      (setf (breaker-pos breaker) new-pos)
      (setf (breaker-last-pos breaker) 0)
      (setf (breaker-cur-class breaker) (normalize-first-break first-class))
      (setf (breaker-next-class breaker) first-class)
      (setf (breaker-lb8a breaker) (= (type-id :ZWJ) first-class))
      (setf (breaker-lb21a breaker) NIL)
      (setf (breaker-lb30a breaker) 0)))
  breaker)

(defun next-break (breaker)
  (declare (optimize speed (safety 1)))
  (let* ((string (breaker-string breaker))
         (pos (breaker-pos breaker))
         (last-pos (breaker-last-pos breaker))
         (cur-class (breaker-cur-class breaker))
         (next-class (breaker-next-class breaker))
         (LB8a (breaker-LB8a breaker))
         (LB21a (breaker-LB21a breaker))
         (LB30a (breaker-LB30a breaker))
         last-class)
    (flet ((finish (break-point mandatory-p)
             (setf (breaker-pos breaker) pos)
             (setf (breaker-last-pos breaker) last-pos)
             (setf (breaker-cur-class breaker) cur-class)
             (setf (breaker-next-class breaker) next-class)
             (setf (breaker-LB8a breaker) LB8a)
             (setf (breaker-LB21a breaker) LB21a)
             (setf (breaker-LB30a breaker) LB30a)
             (return-from next-break (values break-point mandatory-p))))
      (loop while (< pos (length string))
            do (setf last-pos pos)
               (setf last-class next-class)
               (multiple-value-bind (code new-pos) (code-point-at string last-pos)
                 (setf pos new-pos)
                 (setf next-class (normalize-break-id (line-break-id code)))
                 ;; Explicit newline and CRLF handling
                 (when (or (= (type-id :BK) cur-class)
                           (and (= (type-id :CR) cur-class)
                                (/= (type-id :LF) next-class)))
                   (setf cur-class (normalize-first-break next-class))
                   (finish last-pos T))
                 ;; Handle base breaking
                 (let ((next-current (handle-simple-break next-class cur-class))
                       (should-break NIL))
                   (labels ((handle-table-pairs ()
                              (let ((pair (pair-type-id cur-class next-class)))
                                (cond ((= pair (pair-id :DI))
                                       (setf should-break T))
                                      ((= pair (pair-id :IN))
                                       (setf should-break (= last-class (type-id :SP))))
                                      ((= pair (pair-id :CI))
                                       (setf should-break (= last-class (type-id :SP)))
                                       (unless should-break
                                         (return-from handle-table-pairs)))
                                      ((= pair (pair-id :CP))
                                       (unless (= last-class (type-id :SP))
                                         (return-from handle-table-pairs)))))
                              ;; LB8a
                              (when LB8a
                                (setf should-break NIL))
                              ;; LB21a
                              (cond ((and LB21a
                                          (or (= cur-class (type-id :HY))
                                              (= cur-class (type-id :BA))))
                                     (setf should-break NIL)
                                     (setf LB21a NIL))
                                    (T
                                     (setf LB21a (= cur-class (type-id :HL)))))
                              ;; LB30a
                              (cond ((= cur-class (type-id :RI))
                                     (setf LB30a (+ (the idx LB30a) 1))
                                     (when (and (= LB30a 2)
                                                (= next-class (type-id :RI)))
                                       (setf should-break T)
                                       (setf LB30a 0)))
                                    (T
                                     (setf LB30a 0)))
                              (setf cur-class next-class)))
                     (cond (next-current
                            (setf cur-class next-current))
                           (T
                            (handle-table-pairs))))
                   (setf LB8a (= next-class (type-id :ZWJ)))
                   (when should-break
                     (finish last-pos NIL)))))
      (when (<= (length string) pos)
        (cond ((< last-pos (length string))
               (setf last-pos (length string))
               (finish (length string) NIL))
              (T
               (finish NIL NIL)))))))

(defun list-breaks (string)
  (loop with breaker = (make-breaker string)
        for (pos weak) = (next-break breaker)
        while pos
        collect (cons pos weak)))

(defun break-string (string)
  (loop with breaker = (make-breaker string)
        for last = 0 then pos
        for (pos weak) = (multiple-value-list (next-break breaker))
        while pos
        collect (subseq string last pos)))
